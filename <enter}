" Note: Skip initialization for vim-tiny or vim-small.
if 0 | endif

if &compatible
  set nocompatible               " Be iMproved
endif

" Required:
set runtimepath+=~/.vim/bundle/neobundle.vim/

" Required:
call neobundle#begin(expand('~/.vim/bundle/'))

" Let NeoBundle manage NeoBundle
" Required:
NeoBundleFetch 'Shougo/neobundle.vim'
NeoBundle 'bling/vim-airline'
NeoBundle 'christoomey/vim-tmux-navigator'
NeoBundle 'jeffkreeftmeijer/vim-numbertoggle'
NeoBundle 'jiangmiao/auto-pairs'
NeoBundle 'jistr/vim-nerdtree-tabs'
NeoBundle 'kien/ctrlp.vim'
NeoBundle 'majutsushi/tagbar'
NeoBundle 'mkitt/tabline.vim'
NeoBundle 'scrooloose/nerdtree'
NeoBundle 'scrooloose/syntastic'
NeoBundle 'tpope/vim-fugitive'
NeoBundle 'xuyuanp/nerdtree-git-plugin'
NeoBundle 'mhinz/vim-startify'
NeoBundle 'hecal3/vim-leader-guide'
" My Bundles here:
"
" Refer to |:NeoBundle-examples|.
" Note: You don't set neobundle setting in .gvimrc!

call neobundle#end()

" Required:
filetype plugin indent on

" If there are uninstalled bundles found on startup,
" this will conveniently prompt you to install them.
NeoBundleCheck
syntax on
let mapleader = " "
set number relativenumber
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0

"split navigations
nnoremap <C-J> <C-W><C-J>
nnoremap <C-K> <C-W><C-K>
nnoremap <C-L> <C-W><C-L>
nnoremap <C-H> <C-W><C-H>

"Move lines
nnoremap <c-i> :m .+1<CR>==
nnoremap <c-o> :m .-2<CR>==
inoremap <c-i> <Esc>:m .+1<CR>==gi
inoremap <c-o> <Esc>:m .-2<CR>==gi
vnoremap <c-i> :m '>+1<CR>gv=gv
vnoremap <c-o> :m '<-2<CR>gv=gv


"Move Tabs arround
nnoremap <C-Left> :tabprevious<CR>
nnoremap <C-Right> :tabnext<CR>
nnoremap <silent> <A-Left> :execute 'silent! tabmove ' . (tabpagenr()-2)<CR>
nnoremap <silent> <A-Right> :execute 'silent! tabmove ' . (tabpagenr()+1)<CR>

" Enable folding
set foldmethod=indent
set foldlevel=99


map <leader>n :NERDTreeTabsToggle<enter>
map <leader>t :TagbarToggle<enter>
"Quick Exits
map <leader>q :q!<enter>
map <leader>s :w!<enter>
"SCCompile
nmap <C-F9> :SCCompile<cr>
nmap <C-F10> :SCCompileRun<cr>"

" Define prefix dictionary
let g:lmap =  {}
nmap <leader>a :wq!<enter
let g:lmap.a = ['wq!', 'Save and quit']
call leaderGuide#register_prefix_descriptions("<Space>", "g:lmap")
nnoremap <silent> <leader> :<c-u>LeaderGuide '<Space>'<CR>
vnoremap <silent> <leader> :<c-u>LeaderGuideVisual '<Space>'<CR>
